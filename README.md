# Игра «Секретное число»
Представляет из себя ядро – сущности **GameHost, GameMaster и GameSettings**. Дополнительная сущность **GameHostLauncher**. 

Основные сведения о сущностях ядра: 
### GameSettings 
Представляет собой класс которы содержит информацию о настройках игры, минимальное число, максимальное число, количество попыток угадывания. В данной версии игры настройки задаются из файла **App.config** для удобства.  Вспомогательная сущность интерфейс **IGameSettingsProvider** содержит единственный метод *ProvideSettings*. Конкретная реализация как раз и предоставляет настройки из файла конфигурации, при желании можно изменить это и добавить свою реализацию для провайдинга настроек например из стороннего приложения. 
### GameMaster 
Сущность, у которой две ответственности, загадать секретное число и вернуть результат угадывания. Для этого реализован интерфейс **IGameMaster** с двумя методами *GenerateNewSecretNumber(int min, int max) и CheckGuessedValue(int guessed)*. Конкретная реализация для этого интерфейса – **GameMasterBase**. Это абстрактный класс, в нем содержится базовая имплементация для загадывания секретного числа и его угадывания. Для удобства эти методы так же помечены как виртуальные, следовательно, в классах наследниках можно эту логику изменить, например, для проверки угадывания в соответствии с определенными правилами. 
### GameHost 
Это и есть сама игра. При создании объекта в нее внедряется сущность **GameMaster**, сущность настроек **GameSettings**. Игра контролирует количество оставшихся попыток угадывания. 
### Properties.Resources 
Файл ресурсов, содержит локализации строк. 

Дополнительные сущности:
### IGameHostLauncher
Создает игру. Конкретная реализация для консоли это **ConsoleGameHostLauncher**. Тут создается **GameMaster**, **GameSettingsProvider**. Обрабатывается ввод значений пользователем. 

## В рамках реализации SOLID я сделал следующее
1. Класс **GameMasterBase** – Его логическая ответственность загадать секретное число и сказать угадали его или нет. Я почистал, что ему не нужно знать такие детали как количество попыток или в целом настройки игры, он знает только в каком диапазоне загадать число. Так я постарался не нарушить *принцип единственной ответственности*.
2. Чтобы соблюсти принцип *Open-Closed* я в целом старался минимально привязывать детали, в основном все на абстракциях, сохраняя возможности для изменения реализации базовой логики. Например, отнаследовавшись от класса **GameMasterBase** можно реализовать собственную логику проверки угаданного числа или реализовать загадывание секретное числа по специфической логике. Либо можно изменить строки в файле ресурсов, что никак не повлияет на логику работы программы.
3. Мне не удалось в большей степени создать структуру наследования для классов игры, чтобы можно было на конкретном примере указать что сделано для соблюдения *приниципа подстановки Лисков*. Правда, можно наследоваться от базового класса **GameMasterBase**, который реализует интерфейс **IGameMaster**, и в методе, например, *GenerateNewSecretNumber* сделать реализацию, которая не будет предсказуемо генерировать новое секретное число. Тогда это будет соблюдением *принципа подстановки Лисков*.
4. Принцип выделения интерфейсов тут соблюдается, не интерфейсов которые вынудят реализовать методы, которые не нужны. Нет крупных интерфейсов. 
5. Принцип инверсии зависимостей старался соблюсти. Ядро программы не связано сильными связями, практически все на интерфейсах, зависимости внедряются через конструкторы. Исключение это объект **GameSettings**.  Я целенаправленно не выделял для него интерфейс, по сути я строго объявил что это базовые настройки, я не хочу чтобы менялся состав полей. 
